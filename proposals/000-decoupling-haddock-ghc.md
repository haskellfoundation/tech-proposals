# Maximally decoupling Haddock and GHC

## Abstract

<!-- This section should provide a summary of the proposal that identifies the key problems to be solved and summarizes the solution. -->

Haddock is the standard Haskell documentation tool which parses source files and generates documentation in a few formats, most notably HTML. In practice, development and usage of Haddock is strongly coupled to GHC internals, which slows development of Haddock and makes it more difficult for tooling to integrate Haddock.

This proposal seeks to decouple Haddock from GHC as much as possible in two ways. The first way is to add support for a new output format: a serializable intermediate representation (IR) closely matching the current [Haddock abstract syntax tree](https://github.com/haskell/haddock/blob/main/haddock-library/src/Documentation/Haddock/Types.hs#L111). The addition of this new output format would allow for other programs and tools (e.g. Hackage) to query, manipulate, and render documentation. Also, we intend for the IR format to be supported as an input to Haddock, such that the implicit use of GHC could be avoided for certain uses. The second way is to refactor Haddock into GHC-specific components (e.g. parsing), and GHC-agnostic components (e.g. rendering). 

Combined together, these two improvements to Haddock will make it possible to consume and render documentation without touching GHC at all.

## Background

<!-- This section should explain any background (targeting a casual audience) needed to understand the proposal’s motivation (e.g. a high level overview of the technical details and some history). -->

### Haddock

Haddock is the standard Haskell documentation tool. It parses annotated Haskell source files and generates either HTML, LaTeX, or a [Hoogle](https://github.com/ndmitchell/hoogle)-specific output (more on this below). While this output can be viewed locally, users generally consume documentation handled by other tools, most notably [Hackage](https://hackage.haskell.org/) and [Hoogle](https://hoogle.haskell.org/).

To parse documentation from Haskell source files into its abstract syntax tree, [the `haddock` executable makes use of the GHC parser](https://github.com/haskell/haddock/blob/d6b30b11b60543f0a48665f9581af81d25aa9fec/haddock-api/src/Haddock/Parser.hs). GHC can also use the Haddock library to parse documentation and include it in interface files (`*.hi`) with the [`-haddock` flag](https://downloads.haskell.org/ghc/latest/docs/users_guide/using.html?highlight=haddock#haddock). Development and usage of `haddock` is therefore closely tied to GHC.

#### Architecture

The `haddock` executable itself is a thin wrapper around the `haddock-api` package. [As the documentation for the main module of `haddock-api` says](https://github.com/haskell/haddock/blob/d6b30b11b60543f0a48665f9581af81d25aa9fec/haddock-api/src/Documentation/Haddock.hs), the `haddock-api` interface is highly-experimental and should not be considered stable. Currently, `haddock-api` contains the parsing logic, which is GHC-specific. However, `haddock-api` also contains the rendering backends, which controls how documentation is rendered. In principle, rendering logic is GHC-agnostic; however, in practice, some backend modules (e.g. the [HTML backend](https://github.com/haskell/haddock/blob/d6b30b11b60543f0a48665f9581af81d25aa9fec/haddock-api/src/Haddock/Backends/Xhtml.hs)) depend explicitly on the `ghc` package.

Some of the functionality of Haddock is exposed in the `haddock-library` package, on which `haddock-api` depends. The documentation syntax tree is defined in `haddock-library`. Most importantly, while parsing comments from Haskell source files is done by GHC, the parsing of comments into Haddock documentation is done by `haddock-library`. Note that [`haddock-library` is a rather lightweight library](https://hackage.haskell.org/package/haddock-library) which does not depend on any GHC-specific packages.

## Problem statement

Haddock development and usage is closely tied to GHC. This is due to the fact that the `haddock` executable parses documentation (using the GHC parser) and then renders documentation immediately. This artificial connection between parsing and rendering creates the following problems.

### Documentation for projects supporting different versions of GHC

The connection between parsing and rendering in Haddock it makes it difficult to generate documentation for projects which support different versions of GHC. One example of the current limitation is Haddock documentation generated by Hackage. Currently, Hackage only renders documentation when a package is uploaded. The only way to update this documentation is for a maintainer to manually upload rendered documentation. Therefore, the documentation of a package released years ago (e.g. [`gitrev-1.3.1`](https://hackage.haskell.org/package/gitrev-1.3.1/docs/Development-GitRev.html), released in 2017) appears frozen in time.

### Tooling support for querying and manipulating documentation content

The coupling between parsing and rendering in Haddock also makes it difficult for tooling to handle documentation content. Currently, in order for tooling to interact with documentation content, software needs to interface transitively with the GHC parser (through `haddock-api`). An admission of this problem, and a hint towards a solution, is already part of Haddock: Haddock documentation can be rendered in a [Hoogle-specific text format](https://github.com/ndmitchell/hoogle/blob/master/src/Input/Haddock.hs).

We note that the chained parsing and rendering also makes it difficult for non-Haskell projects to interact with documentation content, given that documentation is rendered in hard-to-scrape formats such as HTML and LaTeX. This is a problem for multi-language projects, which generally need to convert all documentation into a common format (e.g. Markdown) before final rendering.

## Prior Art and Related Efforts

<!-- This section should describe prior attempts to solve the problem, other relevant prior work, and what others in the community are doing to address the problem. It should describe the relationship between the proposed work and the existing efforts.
If past attempts did not succeed, this section should provide a theory of why not. -->

[The Rust community has had discussions regarding a JSON-based documentation output](https://rust-lang.github.io/rfcs/2963-rustdoc-json.html). Prior to 2020, `rustdoc` would parse documentation and render HTML immediately. This was problematic because the rendered HTML could not be easily scraped for use by other packages. Since then, `rustdoc` now also supports JSON as an output format, encoding an intermediate representation of documentation, and is used by the [`rust-analyzer`](https://github.com/rust-lang/rust-analyzer) language server.

## Technical Content

<!-- This section should describe the work that is being proposed to the community for comment, including both technical aspects (choices of system architecture, integration with existing tools and workflows) and community governance (how the developed project will be administered, maintained, and otherwise cared for in the future). 
It should also describe the benefits, drawbacks, and risks that are associated with these decisions. -->

We propose to maximally decouple Haddock from GHC in two distinct ways, described below.

### A serializable intemediate representation of documentation 

We propose the creation of a serializable Haddock intermediate representation (IR) output format, backed by JSON. This IR format would closely represent the Haddock syntax tree. This is similar to how Pandoc operates, where documents are parsed into a JSON-serializable format defined in a separate package ([`pandoc-types`](https://hackage.haskell.org/package/pandoc-types)). 

In principle, only parsing is inherently tied to Haskell source code, and hence GHC. Therefore, we also propose that this IR format could be used as an *input* to Haddock, effectively eliminating the use of the GHC parser for some uses. The IR format would be designed with backwards-compatibility as a priority, such that future versions of Haddock can always parse IR generated by older versions of Haddock.

The following sections describe how the creation of the IR format for both input and output solves the problems described above.

#### Documentation for projects supporting different versions of GHC

Having a *backwards-compatible* IR format both as an input and output solves the problem of supporting documentation for projects supporting multiple versions of GHC. This would allow to parse documentation using e.g. `haddock-A.B` into the IR format, and render documentation later using e.g. `haddock-X.Y`, coupled to a later version of GHC:

```txt
Haskell source code --> haddock-A.B --> IR --> haddock-X.Y --> HTML
```

After this proposal is implemented, Hackage could render documentation in the IR format once at upload, and render documentation at will afterwards. As new versions of `hackage-server` are deployed, compiled with different versions of Haddock and GHC, documentation for packages uploaded in the past could be rendered using the latest specifications:

#### Tooling support and integration

Having an IR format whose parsing is de-coupled from GHC makes it more easily embeddable in other tools and libraries. This could lead, for example, to alternative (third-party) documentation-generation backends, where Haddock documentation can be rendered to e.g. Markdown, and thus more easily integrated into multi-language documentation systems. An IR format could also be leveraged to implement programs which transform documentation before rendering, just like [Pandoc filters](https://pandoc.org/filters).

Moreover, having a well-defined IR format serializable to e.g. JSON, allows for tools written in other programming languages to interact with Haskell source code documentation. This might be important for tools such as [`haskell-spotlight`](https://github.com/haskell-spotlight/haskell-spotlight), a Visual Studio Code extension written in TypeScript.

### Refactoring of Haddock

We propose to refactor Haddock into GHC-specific and GHC-agnostic components. GHC-specific components include parsing of Haskell source files to find comments and interactions between GHC and Haddock. All other components are, in principle, GHC-agnostic:

* Parsing comments into documentation;
* Definition of the documentation syntax tree;
* Querying and manipulating the documentation syntax tree;
* Rendering of the documentation syntax tree to an output format such as HTML or LaTeX.

Concretely, we propose:

* Creating a package (tentatively named `haddock-backends`) dedicated to rendering backends. This package would contain the backend logic currently in `haddock-api`, refactored to remove GHC-specific datatypes.
* Moving everything GHC-agnostic and unrelated to rendering backends to the `haddock-library` package.

Factoring out GHC-specific components of Haddock will make it much easier to maintain. The GHC-agnostic components of Haddock will also be easier to integrate into other projects. Most importantly, if Haddock is restricted to take the IR format as an input, it will be possible to render documentation without needing GHC at all.

## Timeline

We expect the following tasks to be performed in order:

1. Refactor Haddock such that rendering backends are decoupled from GHC internals and moved to a new package `haddock-backends`, GHC-specific components are kept in `haddock-api`, and all other GHC-agnostic components are moved to `haddock-library`;
2. Design the IR file format, which is expressive enough to represent Haddock documentation and be backwards-compatible;
3. Implement serialization/deserialization of the Haddock AST in `haddock-library`, allowing for embedding IR support into tooling;
4. Update `haddock` executable to interact with the IR file format as both input and output.

## People

The people involved in executing this work are:

* Laurent P. René de Cotret (@LaurentRDC)

## Budget

No funding from the Haskell Foundation is required to perform the work outlined in this proposal.

## Stakeholders

<!-- Who stands to gain or lose from the implementation of this proposal?
Proposals should identify stakeholders so that they can be contacted for input, and a final decision should not occur without having made a good-faith effort to solicit representative feedback from important stakeholder groups. -->

Broadly, everyone who interacts with Haskell code documentation is a stakeholder. More specifically, this proposal is expected to affect the following groups:

* Haddock maintainers;
* Hackage maintainers, some of which have [expressed a desire to overhaul the documentation-rendering side of things](https://github.com/haskell/haddock/issues/1420);
* Developers of tooling such as [Hoogle](https://github.com/ndmitchell/hoogle), [haskell-language-server](https://github.com/haskell/haskell-language-server), [haskell-spotlight](https://github.com/haskell-spotlight/haskell-spotlight), [Pandoc](https://pandoc.org), and no doubt many more projects.

## Success

<!-- When will the project be considered a success? How long is it expected to take? -->

This project will be considered complete when [Haddock components have been factors and the design and implementation of the IR format in Haddock is complete](#timeline).

In particular, the integration of the IR format outside of the Haddock repository are left for the future.

## Future work

One of the natural extensions of this proposal is to have GHC emit Haddock IR, which would then be consumed by Haddock. Since the IR format will be designed with backwards-compatibility as a priority, the circular dependency between Haddock and GHC would be broken.